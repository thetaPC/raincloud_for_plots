{"version":3,"sources":["data/plots.ts","containers/App/App.tsx","reportWebVitals.ts","index.tsx"],"names":["plotsData","plotA","width","length","minimumWaterRequired","plotB","App","useState","option","setOption","rainDurationText","setRainDurationText","rainDropList","setRainDropList","screenWidth","window","innerWidth","initiateRaincloud","plot","a","t0","performance","now","plants","Map","isAllPlantsWatered","amountOfPlantsWatered","maximumTimeForDropToForm","sizeOfPlot","selectedPlot","console","log","createRainDrop","waterDropletLocation","has","set","get","t1","wait","milliseconds","Promise","res","setTimeout","rainDropTimeToForm","Math","floor","random","rainDropLeftLocation","state","left","className","value","onChange","e","target","id","onClick","map","rainDrop","index","style","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6PAAaA,EAAY,CACvBC,MAAO,CACLC,MAAO,EACPC,OAAQ,EACRC,qBAAsB,GAExBC,MAAO,CACLH,MAAO,EACPC,OAAQ,EACRC,qBAAsB,I,eCoFXE,MAzFf,WAAgB,IAAD,EACeC,mBAAS,SADxB,mBACNC,EADM,KACEC,EADF,OAEmCF,mBAAS,IAF5C,mBAENG,EAFM,KAEYC,EAFZ,OAG2BJ,mBAAS,IAHpC,mBAGNK,EAHM,KAGQC,EAHR,KAKPC,EAAcC,OAAOC,WAEvBC,EAAiB,uCAAG,WAAOC,GAAP,+BAAAC,EAAA,sDAGhBC,EAAaC,YAAYC,MAE/BX,EAAoB,IAIhBY,EAA8B,IAAIC,IAClCC,GAA8B,EAE9BC,EAAgC,EAC9BC,EAAmC,IAMnCC,GAHAC,EAAoB7B,EAAUkB,IAGJhB,MAAQ2B,EAAa1B,OAErD2B,QAAQC,IAAI,cArBU,UAsBdN,EAtBc,kCA2BaO,EAAeJ,EAAYD,GA3BxC,QA2BhBM,EA3BgB,OA4BfV,EAAOW,IAAID,IAMdV,EAAOY,IAAIF,EAAsBV,EAAOa,IAAIH,GAAwB,GAChEJ,EAAazB,uBAAyBmB,EAAOa,IAAIH,IACnDP,MAPFH,EAAOY,IAAIF,EAAsB,GACS,IAAtCJ,EAAazB,sBACfsB,KASAA,IAA0BE,IAC5BH,GAAqB,GAzCH,uBA4CtBK,QAAQC,IAAI,eACNM,EAAKhB,YAAYC,MACvBQ,QAAQC,IAAR,kCAAuCM,EAAKjB,GAAM,IAAlD,cACAT,EAAoB,YAAD,OAAaH,EAAb,kBAA6B6B,EAAKjB,GAAM,IAAxC,cACnBP,EAAgB,IAhDM,4CAAH,sDAmDfyB,EAAO,SAACC,GACZ,OAAO,IAAIC,SAAQ,SAAAC,GAAG,OAAIC,WAAWD,EAAKF,OAGxCP,EAAc,uCAAG,WAAOJ,EAAoBD,GAA3B,iBAAAR,EAAA,6DACfwB,EAAqBC,KAAKC,MAAMD,KAAKE,SAAWnB,GAA4B,EAD7D,SAEbW,EAAKK,GAFQ,cAGnBb,QAAQC,IAAI,QACRgB,EAAuBH,KAAKC,MAAMD,KAAKE,SAAWhC,GAAe,EACrED,GAAgB,SAAAmC,GAAK,4BAAQA,GAAR,CAAe,CAAEC,KAAMF,QALzB,kBAMZH,KAAKC,MAAMD,KAAKE,SAAWlB,GAAc,GAN7B,2CAAH,wDASlB,OACE,sBAAKsB,UAAU,MAAf,UACE,yBAAQC,MAAO3C,EAAQ4C,SAAU,SAAAC,GAAC,OAAI5C,EAAU4C,EAAEC,OAAOH,QAAzD,UACE,wBAAoBA,MAAM,QAA1B,mBAAY,SACZ,wBAAoBA,MAAM,QAA1B,mBAAY,YAGd,wBAAQI,GAAG,OAAOC,QAAS,kBAAMvC,EAAkBT,IAAnD,sBACA,mBAAG+C,GAAG,eAAN,SAAsB7C,IACtB,qBAAK6C,GAAG,YAAR,SACG3C,EAAa6C,KAAI,SAACC,EAAUC,GAC3B,OAAO,qBAAKT,UAAU,OAAOU,MAAO,CAAEX,KAAMS,EAAST,KAAO,gBCxEvDY,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.bff95335.chunk.js","sourcesContent":["export const plotsData = {\n  plotA: {\n    width: 5,\n    length: 5,\n    minimumWaterRequired: 1,\n  },\n  plotB: {\n    width: 5,\n    length: 2,\n    minimumWaterRequired: 3,\n  },\n};\n","import React, { useState } from 'react';\nimport { plotsData } from '../../data/plots';\nimport '../../styles/App/App.css';\n\nfunction App() {\n  const [option, setOption] = useState('plotA');\n  const [rainDurationText, setRainDurationText] = useState('');\n  const [rainDropList, setRainDropList] = useState([]);\n\n  const screenWidth = window.innerWidth;\n\n  let initiateRaincloud = async (plot) => {\n    // TODO: Allow each plot to have different water minimum requirement per plant.\n    // Using performance instead of a setTimeout or setInterval to improve time accuracy.\n    const t0: number = performance.now();\n\n    setRainDurationText('');\n\n    // Hashmap to keep track of how many times a specific plant was watered.\n    // Keeping track of water droplets may be useful for a future feature request.\n    let plants: Map<number, number> = new Map();\n    let isAllPlantsWatered: boolean = false;\n    // This will keep track of how many plants were watered based on minimum water requirements.\n    let amountOfPlantsWatered: number = 0;\n    const maximumTimeForDropToForm: number = 500;\n\n    // TODO: Allow the farmer to select which plot he wants the rain cloud to generate over.\n    const selectedPlot: any = plotsData[plot];\n    /* Using a datasource to determine his plot.\n    This would allow a farmer to select from multiple plots. */\n    const sizeOfPlot = selectedPlot.width * selectedPlot.length;\n\n    console.log('raining...');\n    while (!isAllPlantsWatered) {\n      // Randomize water drop location along with random rain drop creation rate.\n      // This mocks a rain cloud.\n      // In a perfect world, the engineers could generate the droplets within milliseconds.\n      // However, realistically the rain cloud will be limited to its build and the rate won't be perfected.\n      let waterDropletLocation = await createRainDrop(sizeOfPlot, maximumTimeForDropToForm);\n      if (!plants.has(waterDropletLocation)) {\n        plants.set(waterDropletLocation, 1);\n        if (selectedPlot.minimumWaterRequired === 1) {\n          amountOfPlantsWatered++;\n        }\n      } else {\n        plants.set(waterDropletLocation, plants.get(waterDropletLocation) + 1);\n        if (selectedPlot.minimumWaterRequired === plants.get(waterDropletLocation)) {\n          amountOfPlantsWatered++;\n        }\n      }\n      // Check if all plants have been watered.\n      if (amountOfPlantsWatered === sizeOfPlot) {\n        isAllPlantsWatered = true;\n      }\n    }\n    console.log('all watered');\n    const t1 = performance.now();\n    console.log(`Watering the plot took ${(t1 - t0) / 1000} seconds.`);\n    setRainDurationText(`Watering ${option} took ${(t1 - t0) / 1000} seconds.`);\n    setRainDropList([]);\n  };\n\n  const wait = (milliseconds: number): any => {\n    return new Promise(res => setTimeout(res, milliseconds))\n  };\n\n  let createRainDrop = async (sizeOfPlot: number, maximumTimeForDropToForm: number): Promise<number> => {\n    let rainDropTimeToForm = Math.floor(Math.random() * maximumTimeForDropToForm) + 1;\n    await wait(rainDropTimeToForm);\n    console.log('drop');\n    let rainDropLeftLocation = Math.floor(Math.random() * screenWidth) + 1;\n    setRainDropList(state => [...state, { left: rainDropLeftLocation }]);\n    return Math.floor(Math.random() * sizeOfPlot) + 1;\n  };\n\n  return (\n    <div className=\"App\">\n      <select value={option} onChange={e => setOption(e.target.value)}>\n        <option key=\"plotA\" value=\"plotA\">Plot A</option>\n        <option key=\"plotB\" value=\"plotB\">Plot B</option>\n      </select>\n\n      <button id=\"rain\" onClick={() => initiateRaincloud(option)}>Rain Now</button>\n      <p id=\"rainDuration\">{rainDurationText}</p>\n      <div id=\"rainCloud\">\n        {rainDropList.map((rainDrop, index) => {\n          return <div className=\"drop\" style={{ left: rainDrop.left + '%' }}></div>\n        })}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './containers/App/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}